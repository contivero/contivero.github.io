<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My New Hugo Site</title>
    <link>https://contivero.github.io/post/</link>
    <description>Recent content in Posts on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 13 Aug 2022 13:25:02 +0200</lastBuildDate><atom:link href="https://contivero.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>My First Post</title>
      <link>https://contivero.github.io/post/my-first-post/</link>
      <pubDate>Sat, 13 Aug 2022 13:25:02 +0200</pubDate>
      
      <guid>https://contivero.github.io/post/my-first-post/</guid>
      
      <description>&lt;p&gt;Some content&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Tail recursion</title>
      <link>https://contivero.github.io/post/tail-recursion/</link>
      <pubDate>Fri, 12 Aug 2022 13:25:02 +0200</pubDate>
      
      <guid>https://contivero.github.io/post/tail-recursion/</guid>
      
      <description>&lt;p&gt;When a function&amp;rsquo;s last action is calling itself, we say it&amp;rsquo;s &lt;em&gt;tail recursive&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The interest in these functions is that they can be optimized easily by
compilers, which can replace the recursive implementation by a more performant
iterative one. A tail-recursive implementation is able to execute an iterative
process in constant space, even if the process is described by a recursive
procedure.&lt;/p&gt;
&lt;p&gt;Guy L. Steele popularized the automatic optimization of tail
recursions,(although replacing a JSR+RET with JMP was possibly known earlier).&lt;/p&gt;
&lt;p&gt;If there is a tail-recursive implementation of a function, then special
iteration constructs (e.g. while and for loops in languages such as C) are
useful only as syntactic sugar, since the iteration can otherwise be expressed
by the usual function call.&lt;/p&gt;
&lt;h2 id=&#34;examples&#34;&gt;Examples:&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;::&lt;/span&gt; [a] &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;Int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;[]&lt;/span&gt;     &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;length&lt;/span&gt; (x&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;:&lt;/span&gt;xs) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; length xs
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is not tail-recursive. Given that when asking for the length of a list, we
know that we will need to go to the end of it, it makes sense to define length
in a tail-recursive way:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;::&lt;/span&gt; [a] &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;Int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;length&lt;/span&gt; xs &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; lenAcc xs &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;where&lt;/span&gt; lenAcc &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;[]&lt;/span&gt;     n &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; n
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        lenAcc (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;_&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;:&lt;/span&gt;ys) n &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; lenAcc ys (n&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This definition is (with exception of &lt;code&gt;where&lt;/code&gt;) verbatim from Haskell&amp;rsquo;s prelude.&lt;/p&gt;
&lt;p&gt;The standard definition of filter is also not tail-recursive:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;filter&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;[]&lt;/span&gt;     &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;filter&lt;/span&gt; p (x&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;:&lt;/span&gt;xs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; p x       &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;:&lt;/span&gt; filter p xs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; otherwise &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt;     filter p xs
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can define a tail-recursive version as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;filter&lt;/span&gt; f xs &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; filter&amp;#39; xs &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;where&lt;/span&gt; filter&amp;#39; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;[]&lt;/span&gt; rs &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; reverse rs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        filter&amp;#39; x&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;:&lt;/span&gt;xs rs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; f x       &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; filter xs (x &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;:&lt;/span&gt;xs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; otherwise &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; filter&amp;#39; xs rs
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;However, tail recursion imposes strictness, since only the very last call can
return something. This implementation thus fails for infinite lists (e.g. we
can&amp;rsquo;t &lt;code&gt;take 10 (filter even [1..])&lt;/code&gt;), which is generally undesirable.&lt;/p&gt;
&lt;p&gt;The same happens with the standard map:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;map&lt;/span&gt; f &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;[]&lt;/span&gt;     &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;map&lt;/span&gt; f (x&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;:&lt;/span&gt;xs) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; f x &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;:&lt;/span&gt; map f xs
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;which may be defined tail-recursively as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;map&lt;/span&gt; f (x&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;:&lt;/span&gt;xs) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; map&amp;#39; xs &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;where&lt;/span&gt; map&amp;#39; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;[]&lt;/span&gt; rs     &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; reverse rs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        map&amp;#39; (x&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;:&lt;/span&gt;xs) rs &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; map&amp;#39; xs (f x &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;:&lt;/span&gt; rs)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The second equation for &lt;code&gt;map&#39;&lt;/code&gt; is clearly tail-recursive, and since reverse is
tail-recursive, the whole of &lt;code&gt;map&lt;/code&gt; is. This has, however, the same problem as
any tail-recursive function has: it prevents returning a partial result under
lazy evaluation.&lt;/p&gt;
&lt;p&gt;Note that foldl is tail-recursive:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;foldl&lt;/span&gt; f e &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;[]&lt;/span&gt;     &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; e                  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;foldl&lt;/span&gt; f e (x&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;:&lt;/span&gt;xs) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;=&lt;/span&gt; foldl f (f e x) xs
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;However, foldl is discouraged in Haskell because even though it is
tail-recursive, its accumulating parameter isn&amp;rsquo;t evaluated before the recursive
call due to Haskell&amp;rsquo;s normal-order evaluation, for example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  foldl (&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; [&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  foldl (&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;) (&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) [&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  foldl (&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;) ((&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;) [&lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  foldl (&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;) (((&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;) [&lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  foldl (&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;) ((((&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ((((&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (((&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ((&lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#666&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#666&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As can be seen, thunks are created and kept in memory until the end of the list
is reached, and they can start to be evaluated. This is unnecessarily costly,
can lead to stack overflows, and is contrary to what we would normally expect of a
tail-recursive call. That&amp;rsquo;s why there is &lt;code&gt;foldl&#39;&lt;/code&gt;, a strict variant of &lt;code&gt;foldl&lt;/code&gt;
which forces evaluation of each thunk before recursing:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  foldl&amp;#39; (&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; [&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  foldl&amp;#39; (&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;) (&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) [&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  foldl&amp;#39; (&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;) (&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;) [&lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  foldl&amp;#39; (&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;) (&lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;) [&lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  foldl&amp;#39; (&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;) (&lt;span style=&#34;color:#666&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#666&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;comparison-using-c&#34;&gt;Comparison using C&lt;/h2&gt;
&lt;p&gt;Given the two following simple definitions of a factorial function in C:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* tail-recursive-factorial.c */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;fact&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; n, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; acc) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (n &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; acc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; fact(n &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;, n &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; acc);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* iterative-factorial.c */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;fact&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; n) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; ret &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (n &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ret &lt;span style=&#34;color:#666&#34;&gt;*=&lt;/span&gt; n&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; ret;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Both are equivalent, provided we pass &lt;code&gt;1&lt;/code&gt; as the accumulating parameter when
calling the first one (that is, $5!$ would be &lt;code&gt;fact(5, 1)&lt;/code&gt;). The first function
is defined recursively, while the second one iteratively. One might mistakenly
assume the iterative one to be more efficient, but that doesn&amp;rsquo;t need to be the
case. As an example, after calling GCC (version 7.3.1) with &lt;code&gt;-O2 -S&lt;/code&gt; (to enable
optimizations, and generate assembly output), I get the following definitions of
&lt;code&gt;fact&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# iterative-factorial.s
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;fact:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;.LFB11:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#b44&#34;&gt;.cfi_startproc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;test&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;edi&lt;/span&gt;, &lt;span style=&#34;color:#800&#34;&gt;edi&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# Test whether n == 0.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;mov&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;eax&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# ret = 1;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;je&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;.L4&lt;/span&gt;           &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# Go to .L4 if edi was 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;.p2align&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;,,&lt;span style=&#34;color:#666&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#b44&#34;&gt;.p2align&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;.L3:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;imul&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;eax&lt;/span&gt;, &lt;span style=&#34;color:#800&#34;&gt;edi&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# ret *= n;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;sub&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;edi&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# n--;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;jne&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;.L3&lt;/span&gt;           &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# if n != 0, loop once more.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;rep&lt;/span&gt; &lt;span style=&#34;color:#800&#34;&gt;ret&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#b44&#34;&gt;.p2align&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;,,&lt;span style=&#34;color:#666&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#b44&#34;&gt;.p2align&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;.L4:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#b44&#34;&gt;rep&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;ret&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#b44&#34;&gt;.cfi_endproc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# tail-recursive-factorial.s
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;.LFB0:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#b44&#34;&gt;.cfi_startproc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;test&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;edi&lt;/span&gt;, &lt;span style=&#34;color:#800&#34;&gt;edi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;mov&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;eax&lt;/span&gt;, &lt;span style=&#34;color:#800&#34;&gt;esi&lt;/span&gt;      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# store in eax the value of acc.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;je&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;.L5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#b44&#34;&gt;.p2align&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;,,&lt;span style=&#34;color:#666&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#b44&#34;&gt;.p2align&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;.L2:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;imul&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;eax&lt;/span&gt;, &lt;span style=&#34;color:#800&#34;&gt;edi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;sub&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;edi&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;jne&lt;/span&gt;	&lt;span style=&#34;color:#800&#34;&gt;.L2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;.L5:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#b44&#34;&gt;rep&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;ret&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#b44&#34;&gt;.cfi_endproc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Aside from label differences, and some alignment instructions, both codes are
doing exactly the same: multiply eax and edi, decrease edi, and loop until edi
is 0.&lt;/p&gt;
&lt;h2 id=&#34;final-remarks&#34;&gt;Final remarks&lt;/h2&gt;
&lt;p&gt;A downside of tail-recursion is that, since the code is compiled into a loop,
there is no stack trace, which can be counterintuitive when debugging. This is
why python (purposely) doesn&amp;rsquo;t optimize tail-recursive calls.&lt;/p&gt;
&lt;p&gt;References:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;History of tail-call optimization (&lt;a href=&#34;https://erlang.org/pipermail/erlang-questions/2006-August/022055.html&#34;&gt;https://erlang.org/pipermail/erlang-questions/2006-August/022055.html&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Structure and Interpretation of Computer Programs, p.35-36.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.haskell.org/Fold&#34;&gt;https://wiki.haskell.org/Fold&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mail.haskell.org/pipermail/haskell-cafe/2011-March/090237.html&#34;&gt;https://mail.haskell.org/pipermail/haskell-cafe/2011-March/090237.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://neopythonic.blogspot.com.ar/2009/04/tail-recursion-elimination.html&#34;&gt;http://neopythonic.blogspot.com.ar/2009/04/tail-recursion-elimination.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
  </channel>
</rss>

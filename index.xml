<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cristian Ontivero</title><link>https://contivero.github.io/</link><description>Recent content on Cristian Ontivero</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 13 Aug 2022 13:25:02 +0200</lastBuildDate><atom:link href="https://contivero.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Tail recursion</title><link>https://contivero.github.io/post/tail-recursion/</link><pubDate>Sat, 13 Aug 2022 13:25:02 +0200</pubDate><guid>https://contivero.github.io/post/tail-recursion/</guid><description>&lt;p>When a function&amp;rsquo;s last action is calling itself, we say it&amp;rsquo;s &lt;em>tail recursive&lt;/em>.
For instance, a tail recursive implementation of &lt;code>sum&lt;/code> (a function that returns
the sum of all integers in a list) is as follows:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="color:#00a000">sum&lt;/span> &lt;span style="color:#a2f;font-weight:bold">::&lt;/span> [&lt;span style="color:#0b0;font-weight:bold">Int&lt;/span>] &lt;span style="color:#a2f;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#0b0;font-weight:bold">Int&lt;/span>
&lt;span style="color:#00a000">sum&lt;/span> xs &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> sumAcc xs &lt;span style="color:#666">0&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">where&lt;/span> sumAcc &lt;span style="color:#0b0;font-weight:bold">[]&lt;/span> n &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> n
sumAcc (&lt;span style="color:#a2f;font-weight:bold">_&lt;/span>&lt;span style="color:#0b0;font-weight:bold">:&lt;/span>ys) n &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> sumAcc ys (n&lt;span style="color:#666">+&lt;/span>&lt;span style="color:#666">1&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The interest in these functions is that they can be optimized easily by
compilers, which can replace the recursive implementation by a more performant
iterative one. A tail-recursive implementation is able to execute an iterative
process in constant space, even if the process is described by a recursive
procedure.&lt;/p>
&lt;p>The automatic optimization of tail recursions was popularized by Guy L. Steele
(although replacing a JSR+RET with JMP was possibly known earlier).&lt;/p>
&lt;p>If there is a tail-recursive implementation of a function, then special
iteration constructs (e.g. while and for loops in you average imperative or
object-oriented language) are useful only as syntactic sugar, since the
iteration can otherwise be expressed by the usual function call.&lt;/p>
&lt;h2 id="further-examples">Further Examples:&lt;/h2>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="color:#00a000">length&lt;/span> &lt;span style="color:#a2f;font-weight:bold">::&lt;/span> [a] &lt;span style="color:#a2f;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#0b0;font-weight:bold">Int&lt;/span>
&lt;span style="color:#00a000">length&lt;/span> &lt;span style="color:#0b0;font-weight:bold">[]&lt;/span> &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> &lt;span style="color:#666">0&lt;/span>
&lt;span style="color:#00a000">length&lt;/span> (x&lt;span style="color:#0b0;font-weight:bold">:&lt;/span>xs) &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> &lt;span style="color:#666">1&lt;/span> &lt;span style="color:#666">+&lt;/span> length xs
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is not tail-recursive. Given that when asking for the length of a list, we
know that we will need to go to the end of it, it makes sense to define length
in a tail-recursive way:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="color:#00a000">length&lt;/span> &lt;span style="color:#a2f;font-weight:bold">::&lt;/span> [a] &lt;span style="color:#a2f;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#0b0;font-weight:bold">Int&lt;/span>
&lt;span style="color:#00a000">length&lt;/span> xs &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> lenAcc xs &lt;span style="color:#666">0&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">where&lt;/span> lenAcc &lt;span style="color:#0b0;font-weight:bold">[]&lt;/span> n &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> n
lenAcc (&lt;span style="color:#a2f;font-weight:bold">_&lt;/span>&lt;span style="color:#0b0;font-weight:bold">:&lt;/span>ys) n &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> lenAcc ys (n&lt;span style="color:#666">+&lt;/span>&lt;span style="color:#666">1&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This definition is (with exception of &lt;code>where&lt;/code>) verbatim from Haskell&amp;rsquo;s prelude.&lt;/p>
&lt;p>The standard definition of filter is also not tail-recursive:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="color:#00a000">filter&lt;/span> &lt;span style="color:#a2f;font-weight:bold">_&lt;/span> &lt;span style="color:#0b0;font-weight:bold">[]&lt;/span> &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> &lt;span style="color:#0b0;font-weight:bold">[]&lt;/span>
&lt;span style="color:#00a000">filter&lt;/span> p (x&lt;span style="color:#0b0;font-weight:bold">:&lt;/span>xs)
&lt;span style="color:#666">|&lt;/span> p x &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> x &lt;span style="color:#0b0;font-weight:bold">:&lt;/span> filter p xs
&lt;span style="color:#666">|&lt;/span> otherwise &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> filter p xs
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can define a tail-recursive version as follows:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="color:#00a000">filter&lt;/span> f xs &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> filter&amp;#39; xs &lt;span style="color:#0b0;font-weight:bold">[]&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">where&lt;/span> filter&amp;#39; &lt;span style="color:#0b0;font-weight:bold">[]&lt;/span> rs &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> reverse rs
filter&amp;#39; x&lt;span style="color:#0b0;font-weight:bold">:&lt;/span>xs rs
&lt;span style="color:#666">|&lt;/span> f x &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> filter xs (x &lt;span style="color:#0b0;font-weight:bold">:&lt;/span>xs)
&lt;span style="color:#666">|&lt;/span> otherwise &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> filter&amp;#39; xs rs
&lt;/code>&lt;/pre>&lt;/div>&lt;p>However, tail recursion imposes strictness, since only the very last call can
return something. This implementation thus fails for infinite lists (e.g. we
can&amp;rsquo;t &lt;code>take 10 (filter even [1..])&lt;/code>), which is generally undesirable.&lt;/p>
&lt;p>The same happens with the standard map:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="color:#00a000">map&lt;/span> f &lt;span style="color:#0b0;font-weight:bold">[]&lt;/span> &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> &lt;span style="color:#0b0;font-weight:bold">[]&lt;/span>
&lt;span style="color:#00a000">map&lt;/span> f (x&lt;span style="color:#0b0;font-weight:bold">:&lt;/span>xs) &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> f x &lt;span style="color:#0b0;font-weight:bold">:&lt;/span> map f xs
&lt;/code>&lt;/pre>&lt;/div>&lt;p>which may be defined tail-recursively as follows:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="color:#00a000">map&lt;/span> f (x&lt;span style="color:#0b0;font-weight:bold">:&lt;/span>xs) &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> map&amp;#39; xs &lt;span style="color:#0b0;font-weight:bold">[]&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">where&lt;/span> map&amp;#39; &lt;span style="color:#0b0;font-weight:bold">[]&lt;/span> rs &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> reverse rs
map&amp;#39; (x&lt;span style="color:#0b0;font-weight:bold">:&lt;/span>xs) rs &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> map&amp;#39; xs (f x &lt;span style="color:#0b0;font-weight:bold">:&lt;/span> rs)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The second equation for &lt;code>map'&lt;/code> is clearly tail-recursive, and since reverse is
tail-recursive, the whole of &lt;code>map&lt;/code> is. This has, however, the same problem as
any tail-recursive function has: it prevents returning a partial result under
lazy evaluation.&lt;/p>
&lt;p>Note that &lt;code>foldl&lt;/code> is tail-recursive:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-haskell" data-lang="haskell">&lt;span style="color:#00a000">foldl&lt;/span> f e &lt;span style="color:#0b0;font-weight:bold">[]&lt;/span> &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> e
&lt;span style="color:#00a000">foldl&lt;/span> f e (x&lt;span style="color:#0b0;font-weight:bold">:&lt;/span>xs) &lt;span style="color:#a2f;font-weight:bold">=&lt;/span> foldl f (f e x) xs
&lt;/code>&lt;/pre>&lt;/div>&lt;p>However, &lt;code>foldl&lt;/code> is discouraged in Haskell because even though it is
tail-recursive, its accumulating parameter isn&amp;rsquo;t evaluated before the recursive
call due to Haskell&amp;rsquo;s normal-order evaluation. For example, an execution of
&lt;code>foldl (+) 0 [1,2,3,4]&lt;/code> is as follows:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-haskell" data-lang="haskell"> foldl (&lt;span style="color:#666">+&lt;/span>) &lt;span style="color:#666">0&lt;/span> [&lt;span style="color:#666">1&lt;/span>,&lt;span style="color:#666">2&lt;/span>,&lt;span style="color:#666">3&lt;/span>,&lt;span style="color:#666">4&lt;/span>]
foldl (&lt;span style="color:#666">+&lt;/span>) (&lt;span style="color:#666">0&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">1&lt;/span>) [&lt;span style="color:#666">2&lt;/span>,&lt;span style="color:#666">3&lt;/span>,&lt;span style="color:#666">4&lt;/span>]
foldl (&lt;span style="color:#666">+&lt;/span>) ((&lt;span style="color:#666">0&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">1&lt;/span>) &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">2&lt;/span>) [&lt;span style="color:#666">3&lt;/span>,&lt;span style="color:#666">4&lt;/span>]
foldl (&lt;span style="color:#666">+&lt;/span>) (((&lt;span style="color:#666">0&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">1&lt;/span>) &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">2&lt;/span>) &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">3&lt;/span>) [&lt;span style="color:#666">4&lt;/span>]
foldl (&lt;span style="color:#666">+&lt;/span>) ((((&lt;span style="color:#666">0&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">1&lt;/span>) &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">2&lt;/span>) &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">3&lt;/span>) &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">4&lt;/span>) &lt;span style="color:#0b0;font-weight:bold">[]&lt;/span>
((((&lt;span style="color:#666">0&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">1&lt;/span>) &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">2&lt;/span>) &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">3&lt;/span>) &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">4&lt;/span>)
(((&lt;span style="color:#666">1&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">2&lt;/span>) &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">3&lt;/span>) &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">4&lt;/span>)
((&lt;span style="color:#666">3&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">3&lt;/span>) &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">4&lt;/span>)
(&lt;span style="color:#666">6&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">4&lt;/span>)
&lt;span style="color:#666">10&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As can be seen, thunks are created and kept in memory until the end of the list
is reached and they can start to be evaluated. This is unnecessarily costly,
can lead to stack overflows, and is contrary to what we would normally expect of a
tail-recursive call. That&amp;rsquo;s why there is &lt;code>foldl'&lt;/code>, a strict variant of &lt;code>foldl&lt;/code>
which forces evaluation of each thunk before recursing:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-haskell" data-lang="haskell"> foldl&amp;#39; (&lt;span style="color:#666">+&lt;/span>) &lt;span style="color:#666">0&lt;/span> [&lt;span style="color:#666">1&lt;/span>,&lt;span style="color:#666">2&lt;/span>,&lt;span style="color:#666">3&lt;/span>,&lt;span style="color:#666">4&lt;/span>]
foldl&amp;#39; (&lt;span style="color:#666">+&lt;/span>) (&lt;span style="color:#666">0&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">1&lt;/span>) [&lt;span style="color:#666">2&lt;/span>,&lt;span style="color:#666">3&lt;/span>,&lt;span style="color:#666">4&lt;/span>]
foldl&amp;#39; (&lt;span style="color:#666">+&lt;/span>) (&lt;span style="color:#666">1&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">2&lt;/span>) [&lt;span style="color:#666">3&lt;/span>,&lt;span style="color:#666">4&lt;/span>]
foldl&amp;#39; (&lt;span style="color:#666">+&lt;/span>) (&lt;span style="color:#666">3&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">3&lt;/span>) [&lt;span style="color:#666">4&lt;/span>]
foldl&amp;#39; (&lt;span style="color:#666">+&lt;/span>) (&lt;span style="color:#666">6&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">4&lt;/span>) &lt;span style="color:#0b0;font-weight:bold">[]&lt;/span>
&lt;span style="color:#666">10&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="comparison-of-two-factorial-implementations-in-c">Comparison of two factorial implementations in C&lt;/h2>
&lt;p>Given the two following simple definitions of a factorial function in C:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#080;font-style:italic">/* tail-recursive-factorial.c */&lt;/span>
&lt;span style="color:#0b0;font-weight:bold">unsigned&lt;/span>
&lt;span style="color:#00a000">fact&lt;/span>(&lt;span style="color:#0b0;font-weight:bold">unsigned&lt;/span> n, &lt;span style="color:#0b0;font-weight:bold">unsigned&lt;/span> acc) {
&lt;span style="color:#a2f;font-weight:bold">if&lt;/span> (n &lt;span style="color:#666">=&lt;/span>&lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">0&lt;/span>)
&lt;span style="color:#a2f;font-weight:bold">return&lt;/span> acc;
&lt;span style="color:#a2f;font-weight:bold">return&lt;/span> fact(n &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#666">1&lt;/span>, n &lt;span style="color:#666">*&lt;/span> acc);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#080;font-style:italic">/* iterative-factorial.c */&lt;/span>
&lt;span style="color:#0b0;font-weight:bold">unsigned&lt;/span>
&lt;span style="color:#00a000">fact&lt;/span>(&lt;span style="color:#0b0;font-weight:bold">unsigned&lt;/span> n) {
&lt;span style="color:#0b0;font-weight:bold">unsigned&lt;/span> ret &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">1&lt;/span>;
&lt;span style="color:#a2f;font-weight:bold">while&lt;/span> (n &lt;span style="color:#666">!&lt;/span>&lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">0&lt;/span>) {
ret &lt;span style="color:#666">*&lt;/span>&lt;span style="color:#666">=&lt;/span> n&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#666">-&lt;/span>;
}
&lt;span style="color:#a2f;font-weight:bold">return&lt;/span> ret;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Both are equivalent, provided we pass &lt;code>1&lt;/code> as the accumulating parameter when
calling the first one (that is, $5!$ would be &lt;code>fact(5, 1)&lt;/code>). The first function
is defined recursively, while the second one iteratively. One might mistakenly
assume the iterative one to be more efficient, but that doesn&amp;rsquo;t need to be the
case. As an example, after calling GCC (version 7.3.1) with &lt;code>-O2 -S&lt;/code> (to enable
optimizations, and generate assembly output), I get the following definitions of
&lt;code>fact&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">&lt;span style="color:#080;font-style:italic"># iterative-factorial.s
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>
&lt;span style="color:#a0a000">fact:&lt;/span>
&lt;span style="color:#a0a000">.LFB11:&lt;/span>
&lt;span style="color:#b44">.cfi_startproc&lt;/span>
&lt;span style="color:#00a000">test&lt;/span> &lt;span style="color:#800">edi&lt;/span>, &lt;span style="color:#800">edi&lt;/span> &lt;span style="color:#080;font-style:italic"># Test whether n == 0.
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#800">mov&lt;/span> &lt;span style="color:#800">eax&lt;/span>, &lt;span style="color:#666">1&lt;/span> &lt;span style="color:#080;font-style:italic"># ret = 1;
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#800">je&lt;/span> &lt;span style="color:#800">.L4&lt;/span> &lt;span style="color:#080;font-style:italic"># Go to .L4 if edi was 0
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#800">.p2align&lt;/span> &lt;span style="color:#666">4&lt;/span>,,&lt;span style="color:#666">10&lt;/span>
&lt;span style="color:#b44">.p2align&lt;/span> &lt;span style="color:#666">3&lt;/span>
&lt;span style="color:#a0a000">.L3:&lt;/span>
&lt;span style="color:#00a000">imul&lt;/span> &lt;span style="color:#800">eax&lt;/span>, &lt;span style="color:#800">edi&lt;/span> &lt;span style="color:#080;font-style:italic"># ret *= n;
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#800">sub&lt;/span> &lt;span style="color:#800">edi&lt;/span>, &lt;span style="color:#666">1&lt;/span> &lt;span style="color:#080;font-style:italic"># n--;
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#800">jne&lt;/span> &lt;span style="color:#800">.L3&lt;/span> &lt;span style="color:#080;font-style:italic"># if n != 0, loop once more.
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#800">rep&lt;/span> &lt;span style="color:#800">ret&lt;/span>
&lt;span style="color:#b44">.p2align&lt;/span> &lt;span style="color:#666">4&lt;/span>,,&lt;span style="color:#666">10&lt;/span>
&lt;span style="color:#b44">.p2align&lt;/span> &lt;span style="color:#666">3&lt;/span>
&lt;span style="color:#a0a000">.L4:&lt;/span>
&lt;span style="color:#b44">rep&lt;/span> &lt;span style="color:#00a000">ret&lt;/span>
&lt;span style="color:#b44">.cfi_endproc&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">&lt;span style="color:#080;font-style:italic"># tail-recursive-factorial.s
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>
&lt;span style="color:#a0a000">.LFB0:&lt;/span>
&lt;span style="color:#b44">.cfi_startproc&lt;/span>
&lt;span style="color:#00a000">test&lt;/span> &lt;span style="color:#800">edi&lt;/span>, &lt;span style="color:#800">edi&lt;/span>
&lt;span style="color:#00a000">mov&lt;/span> &lt;span style="color:#800">eax&lt;/span>, &lt;span style="color:#800">esi&lt;/span> &lt;span style="color:#080;font-style:italic"># store in eax the value of acc.
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#800">je&lt;/span> &lt;span style="color:#800">.L5&lt;/span>
&lt;span style="color:#b44">.p2align&lt;/span> &lt;span style="color:#666">4&lt;/span>,,&lt;span style="color:#666">10&lt;/span>
&lt;span style="color:#b44">.p2align&lt;/span> &lt;span style="color:#666">3&lt;/span>
&lt;span style="color:#a0a000">.L2:&lt;/span>
&lt;span style="color:#00a000">imul&lt;/span> &lt;span style="color:#800">eax&lt;/span>, &lt;span style="color:#800">edi&lt;/span>
&lt;span style="color:#00a000">sub&lt;/span> &lt;span style="color:#800">edi&lt;/span>, &lt;span style="color:#666">1&lt;/span>
&lt;span style="color:#00a000">jne&lt;/span> &lt;span style="color:#800">.L2&lt;/span>
&lt;span style="color:#a0a000">.L5:&lt;/span>
&lt;span style="color:#b44">rep&lt;/span> &lt;span style="color:#00a000">ret&lt;/span>
&lt;span style="color:#b44">.cfi_endproc&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Aside from label differences, and some alignment instructions, both codes are
doing exactly the same: multiply eax and edi, decrease edi, and loop until edi
is 0.&lt;/p>
&lt;h2 id="final-remarks">Final remarks&lt;/h2>
&lt;p>A downside of tail-recursion is that, since the code is compiled into a loop,
there is no stack trace, which can be counterintuitive when debugging. This is
why python (purposely) doesn&amp;rsquo;t optimize tail-recursive calls.&lt;/p>
&lt;h2 id="references">References:&lt;/h2>
&lt;ol>
&lt;li>History of tail-call optimization (&lt;a href="https://erlang.org/pipermail/erlang-questions/2006-August/022055.html">https://erlang.org/pipermail/erlang-questions/2006-August/022055.html&lt;/a>)&lt;/li>
&lt;li>Structure and Interpretation of Computer Programs, p.35-36.&lt;/li>
&lt;li>&lt;a href="https://wiki.haskell.org/Fold">https://wiki.haskell.org/Fold&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mail.haskell.org/pipermail/haskell-cafe/2011-March/090237.html">https://mail.haskell.org/pipermail/haskell-cafe/2011-March/090237.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://neopythonic.blogspot.com.ar/2009/04/tail-recursion-elimination.html">http://neopythonic.blogspot.com.ar/2009/04/tail-recursion-elimination.html&lt;/a>&lt;/li>
&lt;/ol></description></item></channel></rss>